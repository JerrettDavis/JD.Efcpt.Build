using JD.Efcpt.Build.Definitions.Builders;
using JD.Efcpt.Build.Definitions.Constants;
using JD.Efcpt.Build.Definitions.Registry;
using JD.Efcpt.Build.Definitions.Shared;
using JD.MSBuild.Fluent.Fluent;
using JD.MSBuild.Fluent.IR;
using static JD.Efcpt.Build.Definitions.Constants.MsBuildExpressions;
using static JD.Efcpt.Build.Definitions.Builders.TargetFactory;
using static JD.Efcpt.Build.Definitions.Builders.FileOperationBuilder;
using static JD.Efcpt.Build.Definitions.Constants.PipelineConstants;

// Type aliases for property classes (reduces line length)
using P = JD.Efcpt.Build.Definitions.Constants.MsBuildProperties;
using E = JD.Efcpt.Build.Definitions.Constants.EfcptProperties;
using T = JD.Efcpt.Build.Definitions.Constants.EfcptTargets;
using Tk = JD.Efcpt.Build.Definitions.Constants.EfcptTasks;
using Pm = JD.Efcpt.Build.Definitions.Constants.TaskParameters;
using V = JD.Efcpt.Build.Definitions.Constants.PropertyValues;
using Mt = JD.Efcpt.Build.Definitions.Constants.MsBuildTasks;

namespace JD.Efcpt.Build.Definitions;

/// <summary>
/// MSBuild package definition scaffolded from JD.Efcpt.Build.xml
/// </summary>
public static class BuildTransitiveTargetsFactory
{
    public static MsBuildProject Create()
    {
        var project = new MsBuildProject { Label = "Generated by JD.MSBuild.Fluent" };
        var t = TargetsBuilder.For(project);

        t.Comment(
            "Late-evaluated property overrides set in targets file " +
            "(after project import) to see final property values.");
        t.PropertyGroup(null, group =>
        {
            group.Comment(
                "Derive UseNullableReferenceTypes from project's " +
                "Nullable setting for zero-config scenarios");
            group.Property(
                E.EfcptConfigUseNullableReferenceTypes,
                V.True,
                Condition_And(
                    Condition_IsEmpty(E.EfcptConfigUseNullableReferenceTypes),
                    Condition_Or(
                        Condition_Equals(P.Nullable, V.Enable),
                        Condition_Equals(P.Nullable, V.Enable_Capitalized)
                    )
                ));
            group.Property(
                E.EfcptConfigUseNullableReferenceTypes,
                V.False,
                Condition_And(
                    Condition_IsEmpty(E.EfcptConfigUseNullableReferenceTypes),
                    Condition_NotEmpty(P.Nullable)
                ));
        });
        t.Comment(
            "SQL Project Detection: Detect SQL database projects via " +
            "SDK attribute or MSBuild properties. Must be in targets " +
            "file for SDK property availability.");
        t.Target(T._EfcptDetectSqlProject, target =>
        {
            target.BeforeTargets(
                Path_Combine(MsBuildTargets.BeforeBuild, MsBuildTargets.BeforeRebuild));
            target.Task(Tk.DetectSqlProject, task =>
            {
                task.MapProps(
                    (Pm.ProjectPath, P.MSBuildProjectFullPath),
                    (Pm.SqlServerVersion, P.SqlServerVersion),
                    (Pm.DSP, P.DSP))
                    .OutputProperty(Pm.IsSqlProject, E._EfcptIsSqlProject);
            });
            target.PropertyGroup(
                Condition_IsEmpty(E._EfcptIsSqlProject),
                group =>
            {
                group.Property(E._EfcptIsSqlProject, V.False);
            });
        });
        t.Comment(
            "Determine the correct task assembly path based on " +
            "MSBuild runtime and version.");
        t.PropertyGroup(null, SharedPropertyGroups.ConfigureTaskAssemblyResolution);
        t.Comment(
            "Diagnostic output for task assembly selection " +
            "(when EfcptLogVerbosity=detailed)");
        t.Target(T._EfcptLogTaskAssemblyInfo, target =>
        {
            target.BeforeTargets(
                Path_Combine(T.EfcptResolveInputs, T.EfcptResolveInputsForDirectDacpac));
            target.Condition(
                Condition_And(
                    Condition_IsTrue(E.EfcptEnabled),
                    Condition_Equals(E.EfcptLogVerbosity, V.Detailed)));
            target.Message(
                $"EFCPT Task Assembly Selection:",
                V.High);
            target.Message(
                $"  MSBuildRuntimeType: {Property(P.MSBuildRuntimeType)}",
                V.High);
            target.Message(
                $"  MSBuildVersion: {Property(P.MSBuildVersion)}",
                V.High);
            target.Message(
                $"  Selected TasksFolder: {Property(E._EfcptTasksFolder)}",
                V.High);
            target.Message(
                $"  TaskAssembly Path: {Property(E._EfcptTaskAssembly)}",
                V.High);
            target.Message(
                $"  TaskAssembly Exists: {FileExists(Property(E._EfcptTaskAssembly))}",
                V.High);
        });
        t.Comment("Register MSBuild tasks using centralized registry.");
        UsingTasksRegistry.RegisterAll(t);
        t.Comment(
            "Build Profiling: Initialize profiling at the start of " +
            "the build pipeline. Runs early to ensure profiler " +
            "availability.");
        t.AddEfcptTarget(T._EfcptInitializeProfiling)
            .WhenEnabled()
            .Before(T._EfcptDetectSqlProject)
            .Build()
            .Task(Tk.InitializeBuildProfiling, task =>
            {
                task.MapParameters()
                    .WithProjectContext()
                    .WithInputFiles()
                    .WithDacpac()
                    .Build()
                    .Param(Pm.EnableProfiling, Property(E.EfcptEnableProfiling))
                    .Param(Pm.Provider, Property(E.EfcptProvider));
            });
        t.Comment(
            "SDK Version Check: Warns users when a newer SDK version " +
            "is available. Opt-in via EfcptCheckForUpdates=true. " +
            "Results are cached for 24 hours.");
        t.Target(T._EfcptCheckForUpdates, target =>
        {
            target.BeforeTargets(MsBuildTargets.Build);
            target.Condition(
                Condition_And(
                    Condition_IsTrue(E.EfcptCheckForUpdates),
                    Condition_NotEmpty(E.EfcptSdkVersion)));
            target.Task(Tk.CheckSdkVersion, task =>
            {
                task.MapProps(
                    (Pm.CurrentVersion, E.EfcptSdkVersion),
                    (Pm.CacheHours, E.EfcptUpdateCheckCacheHours),
                    (Pm.ForceCheck, E.EfcptForceUpdateCheck),
                    (Pm.WarningLevel, E.EfcptSdkVersionWarningLevel))
                    .Param(Pm.PackageId, V.JD_Efcpt_Sdk)
                    .OutputProperty(Pm.LatestVersion, E._EfcptLatestVersion)
                    .OutputProperty(Pm.UpdateAvailable, E._EfcptUpdateAvailable);
            });
        });
        t.Comment(
            "SQL Project Generation Pipeline: Extract database schema " +
            "to SQL scripts for SQL projects. Workflow: Database → " +
            "SQL Scripts → DACPAC → EF Core Models");
        t.Comment(
            "Lifecycle hooks: BeforeSqlProjGeneration, " +
            "AfterSqlProjGeneration, BeforeEfcptGeneration, " +
            "AfterEfcptGeneration");
        t.Comment("Lifecycle hook: BeforeSqlProjGeneration");
        CreateLifecycleHook(
            t,
            T.BeforeSqlProjGeneration,
            condition: Condition_And(
                Condition_IsTrue(E.EfcptEnabled),
                Condition_IsTrue(E._EfcptIsSqlProject)));
        t.Comment("Query database schema for fingerprinting");
        t.AddEfcptTarget(T.EfcptQueryDatabaseSchemaForSqlProj)
            .ForSqlProjectGeneration()
            .DependsOn(T.BeforeSqlProjGeneration)
            .Build()
            .Error(
                "SqlProj generation requires a connection string. " +
                "Set EfcptConnectionString, EfcptAppSettings, or " +
                "EfcptAppConfig.",
                Condition_And(
                    Condition_And(
                        Condition_IsEmpty(E.EfcptConnectionString),
                        Condition_IsEmpty(E.EfcptAppSettings)
                    ),
                    Condition_IsEmpty(E.EfcptAppConfig)
                ))
            .Message(
                "Querying database schema for fingerprinting...",
                V.High)
            .Task(Tk.QuerySchemaMetadata, task =>
            {
                task.MapParameters()
                    .WithDatabaseConnection()
                    .WithOutput()
                    .Build()
                    .OutputProperty(Pm.SchemaFingerprint, E._EfcptSchemaFingerprint);
            })
            .Message(
                $"Database schema fingerprint: {Property(E._EfcptSchemaFingerprint)}",
                V.Normal);
        t.Comment("Extract database schema to SQL scripts using sqlpackage");
        t.AddEfcptTarget(T.EfcptExtractDatabaseSchemaToScripts)
            .ForSqlProjectGeneration()
            .DependsOn(T.EfcptQueryDatabaseSchemaForSqlProj)
            .Build()
            .PropertyGroup(null, group =>
            {
                group.Property(
                    E._EfcptScriptsDir,
                    Property(E.EfcptSqlScriptsDir));
            })
            .Message(
                $"Extracting database schema to SQL scripts in SQL project: {Property(E._EfcptScriptsDir)}",
                V.High)
            .ItemGroup(null, group =>
            {
                group.Include(
                    E._EfcptGeneratedScripts,
                    $"{Property(E._EfcptScriptsDir)}**\\*.sql");
            })
            .Task(
                Mt.Delete,
                task =>
            {
                task.Param(Pm.Files, ItemList(E._EfcptGeneratedScripts));
            },
                ItemList_NotEmpty(E._EfcptGeneratedScripts))
            .Task(Tk.RunSqlPackage, task =>
            {
                task.MapProps(
                    (Pm.ToolVersion, E.EfcptSqlPackageToolVersion),
                    (Pm.ToolRestore, E.EfcptSqlPackageToolRestore),
                    (Pm.ToolPath, E.EfcptSqlPackageToolPath),
                    (Pm.DotNetExe, E.EfcptDotNetExe),
                    (Pm.WorkingDirectory, E.EfcptOutput),
                    (Pm.ConnectionString, E.EfcptConnectionString),
                    (Pm.TargetDirectory, E._EfcptScriptsDir),
                    (Pm.TargetFramework, P.TargetFramework),
                    (Pm.LogVerbosity, E.EfcptLogVerbosity))
                    .Param(Pm.ExtractTarget, V.SchemaObjectType)
                    .OutputProperty(
                        Pm.ExtractedPath,
                        E._EfcptExtractedScriptsPath);
            })
            .Message(
                $"Extracted SQL scripts to: {Property(E._EfcptExtractedScriptsPath)}",
                V.High);
        t.Comment("Add auto-generation warnings to SQL files");
        t.AddEfcptTarget(T.EfcptAddSqlFileWarnings)
            .ForSqlProjectGeneration()
            .DependsOn(T.EfcptExtractDatabaseSchemaToScripts)
            .LogInfo("Adding auto-generation warnings to SQL files...")
            .Build()
            .PropertyGroup(null, group =>
            {
                group.Property(
                    E._EfcptDatabaseName,
                    "$([System.Text.RegularExpressions.Regex]::Match(" +
                    "$(EfcptConnectionString), " +
                    "'Database\\s*=\\s*\\\"?([^;\"]+)\\\"?').Groups[1].Value)");
                group.Property(
                    E._EfcptDatabaseName,
                    "$([System.Text.RegularExpressions.Regex]::Match(" +
                    "$(EfcptConnectionString), " +
                    "'Initial Catalog\\s*=\\s*\\\"?([^;\"]+)\\\"?').Groups[1].Value)");
            })
            .Task(Tk.AddSqlFileWarnings, task =>
            {
                task.MapProps(
                    (Pm.ScriptsDirectory, E._EfcptScriptsDir),
                    (Pm.DatabaseName, E._EfcptDatabaseName),
                    (Pm.LogVerbosity, E.EfcptLogVerbosity));
            });
        // Lifecycle hook: AfterSqlProjGeneration
        // This runs after SQL scripts are generated in the SQL project
        // The SQL project will build normally and create its DACPAC
        t.Comment("Lifecycle hook: AfterSqlProjGeneration");
        t.Comment(
            "This runs after SQL scripts are generated in the SQL " +
            "project");
        t.Comment(
            "The SQL project will build normally and create its DACPAC");
        t.Comment(
            "DataAccess projects that reference this SQL project will " +
            "wait for this to complete");
        t.AddEfcptTarget(T.AfterSqlProjGeneration)
            .ForSqlProjectGeneration()
            .DependsOn(T.EfcptAddSqlFileWarnings)
            .Before(MsBuildTargets.Build)
            .LogInfo(
                $"_EfcptIsSqlProject: {Property(E._EfcptIsSqlProject)}")
            .LogInfo(
                "SQL script generation complete. " +
                "SQL project will build to DACPAC.")
            .Build();
        t.Comment("Main pipeline");
        t.Comment("When NOT in a SQL project, resolve inputs normally");
        t.Target(T.EfcptResolveInputs, target =>
        {
            target.Condition(
                Condition_And(
                    Condition_And(
                        Condition_IsTrue(E.EfcptEnabled),
                        Condition_IsFalse(E._EfcptIsSqlProject)
                    ),
                    Condition_IsEmpty(E.EfcptDacpac)
                ));
            target.Task(Tk.ResolveSqlProjAndInputs, task =>
            {
                task.MapProps(
                    (Pm.ProjectFullPath, P.MSBuildProjectFullPath),
                    (Pm.ProjectDirectory, P.MSBuildProjectDirectory),
                    (Pm.Configuration, P.Configuration),
                    (Pm.SqlProjOverride, E.EfcptSqlProj),
                    (Pm.ConfigOverride, E.EfcptConfig),
                    (Pm.RenamingOverride, E.EfcptRenaming),
                    (Pm.TemplateDirOverride, E.EfcptTemplateDir),
                    (Pm.SolutionDir, E.EfcptSolutionDir),
                    (Pm.SolutionPath, E.EfcptSolutionPath),
                    (Pm.ProbeSolutionDir, E.EfcptProbeSolutionDir),
                    (Pm.OutputDir, E.EfcptOutput),
                    (Pm.DumpResolvedInputs, E.EfcptDumpResolvedInputs),
                    (Pm.EfcptConnectionString, E.EfcptConnectionString),
                    (Pm.EfcptAppSettings, E.EfcptAppSettings),
                    (Pm.EfcptAppConfig, E.EfcptAppConfig),
                    (Pm.EfcptConnectionStringName, E.EfcptConnectionStringName),
                    (Pm.AutoDetectWarningLevel, E.EfcptAutoDetectWarningLevel))
                    .Param(
                        Pm.ProjectReferences,
                        ItemList(MsBuildItems.ProjectReference))
                    .Param(
                        Pm.DefaultsRoot,
                        $"{Property(P.MSBuildThisFileDirectory)}{V.Defaults}")
                    .OutputProperty(Pm.SqlProjPath, E._EfcptSqlProj)
                    .OutputProperty(Pm.ResolvedConfigPath, E._EfcptResolvedConfig)
                    .OutputProperty(
                        Pm.ResolvedRenamingPath,
                        E._EfcptResolvedRenaming)
                    .OutputProperty(
                        Pm.ResolvedTemplateDir,
                        E._EfcptResolvedTemplateDir)
                    .OutputProperty(
                        Pm.ResolvedConnectionString,
                        E._EfcptResolvedConnectionString)
                    .OutputProperty(
                        Pm.UseConnectionString,
                        E._EfcptUseConnectionString)
                    .OutputProperty(
                        Pm.IsUsingDefaultConfig,
                        E._EfcptIsUsingDefaultConfig);
            });
        });
        t.Comment(
            "Simplified resolution for direct DACPAC mode " +
            "(bypass SQL project detection)");
        t.Target(T.EfcptResolveInputsForDirectDacpac, target =>
        {
            target.Condition(
                Condition_And(
                    Condition_IsTrue(E.EfcptEnabled),
                    Condition_NotEmpty(E.EfcptDacpac)
                ));
            target.PropertyGroup(null, group =>
            {
                group.Property(
                    E._EfcptResolvedConfig,
                    $"{Property(P.MSBuildProjectDirectory)}\\{Property(E.EfcptConfig)}");
                group.Property(
                    E._EfcptResolvedConfig,
                    $"{Property(P.MSBuildThisFileDirectory)}{V.Defaults}\\{V.EfcptConfigJson}");
                group.Property(
                    E._EfcptResolvedRenaming,
                    $"{Property(P.MSBuildProjectDirectory)}\\{Property(E.EfcptRenaming)}");
                group.Property(
                    E._EfcptResolvedRenaming,
                    $"{Property(P.MSBuildThisFileDirectory)}{V.Defaults}\\{V.EfcptRenamingJson}");
                group.Property(
                    E._EfcptResolvedTemplateDir,
                    $"{Property(P.MSBuildProjectDirectory)}\\{Property(E.EfcptTemplateDir)}");
                group.Property(
                    E._EfcptResolvedTemplateDir,
                    $"{Property(P.MSBuildThisFileDirectory)}{V.Defaults}\\{V.Template}");
                group.Property(E._EfcptIsUsingDefaultConfig, V.True);
                group.Property(E._EfcptUseConnectionString, V.False);
            });
            AddMakeDir(target, E.EfcptOutput);
        });
        t.Target(T.EfcptQuerySchemaMetadataForDb, target =>
        {
            target.BeforeTargets(T.EfcptStageInputs);
            target.AfterTargets(T.EfcptResolveInputs);
            target.Condition(
                Condition_And(
                    Condition_And(
                        Condition_IsTrue(E.EfcptEnabled),
                        Condition_IsFalse(E._EfcptIsSqlProject)
                    ),
                    Condition_IsTrue(E._EfcptUseConnectionString)
                ));
            target.Task(Tk.QuerySchemaMetadata, task =>
            {
                task.Param(
                    Pm.ConnectionString,
                    Property(E._EfcptResolvedConnectionString));
                task.MapParameters()
                    .WithOutput()
                    .Build()
                    .OutputProperty(Pm.SchemaFingerprint, E._EfcptSchemaFingerprint);
            });
        });
        t.Target(T.EfcptUseDirectDacpac, target =>
        {
            target.DependsOnTargets(
                $"{T.EfcptResolveInputs};{T.EfcptResolveInputsForDirectDacpac}");
            target.Condition(
                Condition_And(
                    Condition_And(
                        Condition_IsTrue(E.EfcptEnabled),
                        Condition_IsFalse(E._EfcptUseConnectionString)
                    ),
                    Condition_NotEmpty(E.EfcptDacpac)
                ));
            target.PropertyGroup(null, group =>
            {
                group.Property(E._EfcptDacpacPath, Property(E.EfcptDacpac));
                group.Property(
                    E._EfcptDacpacPath,
                    "$([System.IO.Path]::GetFullPath(" +
                    "$([System.IO.Path]::Combine(" +
                    $"'{Property(P.MSBuildProjectDirectory)}', " +
                    $"'{Property(E.EfcptDacpac)}'))))");
                group.Property(E._EfcptUseDirectDacpac, V.True);
            });
            target.Error(
                $"EfcptDacpac was specified but the file does not " +
                $"exist: {Property(E._EfcptDacpacPath)}",
                Condition_NotExists(Property(E._EfcptDacpacPath)));
            target.Message(
                $"Using pre-built DACPAC: {Property(E._EfcptDacpacPath)}",
                V.High);
        });
        // Build the SQL project using MSBuild's native task to ensure
        // proper dependency ordering. This prevents race conditions
        // when MSBuild runs in parallel mode - the SQL project build
        // will complete before any targets that depend on this one can
        // proceed. Note: The mode-specific condition (checking
        // connection string vs dacpac mode) is on the MSBuild task,
        // not the target, because target conditions evaluate before
        // DependsOnTargets complete. The target's EfcptEnabled
        // condition is a simple enable/disable check.
        t.Comment(
            "Build the SQL project using MSBuild's native task to " +
            "ensure proper dependency ordering. This prevents race " +
            "conditions when MSBuild runs in parallel mode - the SQL " +
            "project build will complete before any targets that " +
            "depend on this one can proceed. Note: The mode-specific " +
            "condition (checking connection string vs dacpac mode) is " +
            "on the MSBuild task, not the target, because target " +
            "conditions evaluate before DependsOnTargets complete. " +
            "The target's EfcptEnabled condition is a simple " +
            "enable/disable check.");
        t.Target(T.EfcptBuildSqlProj, target =>
        {
            target.DependsOnTargets(
                $"{T.EfcptResolveInputs};{T.EfcptUseDirectDacpac}");
            target.Condition(Condition_IsTrue(E.EfcptEnabled));
            var buildCondition = Condition_And(
                Condition_And(
                    Condition_IsFalse(E._EfcptUseConnectionString),
                    Condition_IsFalse(E._EfcptUseDirectDacpac)
                ),
                Condition_NotEmpty(E._EfcptSqlProj));
            target.Message(
                $"Building SQL project: {Property(E._EfcptSqlProj)}",
                V.Normal,
                buildCondition);
            target.Task(Mt.MSBuild, task =>
            {
                task.MapParameters().WithMsBuildInvocation();
            }, buildCondition);
        });
        // EfcptEnsureDacpac: Build dacpac if needed (not in
        // connection string mode). Note: The condition check happens
        // INSIDE the target (not on the target itself) because target
        // conditions are evaluated before DependsOnTargets run.
        t.Comment(
            "EfcptEnsureDacpac: Build dacpac if needed (not in " +
            "connection string mode). Note: The condition check " +
            "happens INSIDE the target (not on the target itself) " +
            "because target conditions are evaluated before " +
            "DependsOnTargets run.");
        t.Target(T.EfcptEnsureDacpacBuilt, target =>
        {
            target.DependsOnTargets(
                $"{T.EfcptResolveInputs};{T.EfcptUseDirectDacpac};{T.EfcptBuildSqlProj}");
            target.Condition(Condition_IsTrue(E.EfcptEnabled));
            var ensureCondition = Condition_And(
                Condition_And(
                    Condition_IsFalse(E._EfcptUseConnectionString),
                    Condition_IsFalse(E._EfcptUseDirectDacpac)
                ),
                Condition_IsFalse(E._EfcptIsSqlProject));
            target.Task(Tk.EnsureDacpacBuilt, task =>
            {
                task.MapProps(
                    (Pm.SqlProjPath, E._EfcptSqlProj),
                    (Pm.Configuration, P.Configuration),
                    (Pm.DotNetExe, E.EfcptDotNetExe),
                    (Pm.LogVerbosity, E.EfcptLogVerbosity))
                    .Param(
                        Pm.MsBuildExe,
                        $"{Property(P.MSBuildBinPath)}{V.MsBuildExe}")
                    .OutputProperty(Pm.DacpacPath, E._EfcptDacpacPath);
            }, ensureCondition);
        });
        // Resolve DbContext name from SQL project, DACPAC, or
        // connection string. This runs after DACPAC is ensured/resolved
        // but before staging to allow the resolved name to be used as
        // an override in ApplyConfigOverrides.
        t.Comment(
            "Resolve DbContext name from SQL project, DACPAC, or " +
            "connection string. This runs after DACPAC is " +
            "ensured/resolved but before staging to allow the resolved " +
            "name to be used as an override in ApplyConfigOverrides.");
        t.AddEfcptTarget(T.EfcptResolveDbContextName)
            .ForEfCoreGeneration()
            .DependsOn(
                T.EfcptResolveInputs,
                T.EfcptEnsureDacpacBuilt,
                T.EfcptUseDirectDacpac)
            .Build()
            .Task(Tk.ResolveDbContextName, task =>
            {
                task.MapProps(
                    (Pm.ExplicitDbContextName, E.EfcptConfigDbContextName),
                    (Pm.SqlProjPath, E._EfcptSqlProj),
                    (Pm.DacpacPath, E._EfcptDacpacPath),
                    (Pm.ConnectionString, E._EfcptResolvedConnectionString),
                    (Pm.UseConnectionString, E._EfcptUseConnectionString),
                    (Pm.LogVerbosity, E.EfcptLogVerbosity))
                    .OutputProperty(
                        Pm.ResolvedDbContextName,
                        E._EfcptResolvedDbContextName);
            })
            .PropertyGroup(null, group =>
            {
                group.Property(
                    E.EfcptConfigDbContextName,
                    Property(E._EfcptResolvedDbContextName));
            });
        t.SingleTask(T.EfcptStageInputs, PreGenChain, Tk.StageEfcptInputs, task =>
        {
            task.MapProps(
                (Pm.OutputDir, E.EfcptOutput),
                (Pm.ProjectDirectory, P.MSBuildProjectDirectory),
                (Pm.ConfigPath, E._EfcptResolvedConfig),
                (Pm.RenamingPath, E._EfcptResolvedRenaming),
                (Pm.TemplateDir, E._EfcptResolvedTemplateDir),
                (Pm.TemplateOutputDir, E.EfcptGeneratedDir),
                (Pm.TargetFramework, P.TargetFramework),
                (Pm.LogVerbosity, E.EfcptLogVerbosity))
                .OutputProperty(Pm.StagedConfigPath, E._EfcptStagedConfig)
                .OutputProperty(Pm.StagedRenamingPath, E._EfcptStagedRenaming)
                .OutputProperty(Pm.StagedTemplateDir, E._EfcptStagedTemplateDir);
        });
        // Apply MSBuild property overrides to the staged efcpt-config.json file.
        t.Comment("Apply MSBuild property overrides to the staged efcpt-config.json file. Runs after staging but before fingerprinting to ensure overrides are included in the hash.");
        t.AddEfcptTarget(T.EfcptApplyConfigOverrides)
            .ForEfCoreGeneration()
            .DependsOn(T.EfcptStageInputs)
            .Build()
            .Task(Tk.ApplyConfigOverrides, task =>
            {
                task.MapParameters()
                    .WithAllConfigOverrides()
                    .Build()
                    .Param(Pm.StagedConfigPath, Property(E._EfcptStagedConfig))
                    .Param(Pm.ApplyOverrides, Property(E.EfcptApplyMsBuildOverrides))
                    .Param(Pm.IsUsingDefaultConfig, Property(E._EfcptIsUsingDefaultConfig))
                    .Param(Pm.LogVerbosity, Property(E.EfcptLogVerbosity));
            });
        // Serialize MSBuild config property overrides to a JSON string for fingerprinting.
        t.Comment("Serialize MSBuild config property overrides to a JSON string for fingerprinting. This ensures that changes to EfcptConfig* properties trigger regeneration.");
        t.AddEfcptTarget(T.EfcptSerializeConfigProperties)
            .ForEfCoreGeneration()
            .DependsOn(T.EfcptApplyConfigOverrides)
            .Build()
            .Task(Tk.SerializeConfigProperties, task =>
            {
                task.MapParameters()
                    .WithAllConfigOverrides()
                    .Build()
                    .OutputProperty(Pm.SerializedProperties, E._EfcptSerializedConfigProperties);
            });
        t.SingleTask(T.EfcptComputeFingerprint, 
            string.Join(";", T.EfcptSerializeConfigProperties), 
            Tk.ComputeFingerprint, task =>
        {
            task.MapProps(
                (Pm.DacpacPath, E._EfcptDacpacPath),
                (Pm.SchemaFingerprint, E._EfcptSchemaFingerprint),
                (Pm.UseConnectionString, E._EfcptUseConnectionString),
                (Pm.ConfigPath, E._EfcptStagedConfig),
                (Pm.RenamingPath, E._EfcptStagedRenaming),
                (Pm.TemplateDir, E._EfcptStagedTemplateDir),
                (Pm.FingerprintFile, E.EfcptFingerprintFile),
                (Pm.ToolVersion, E.EfcptToolVersion),
                (Pm.GeneratedDir, E.EfcptGeneratedDir),
                (Pm.DetectGeneratedFileChanges, E.EfcptDetectGeneratedFileChanges),
                (Pm.ConfigPropertyOverrides, E._EfcptSerializedConfigProperties),
                (Pm.LogVerbosity, E.EfcptLogVerbosity))
                .OutputProperty(Pm.Fingerprint, E._EfcptFingerprint)
                .OutputProperty(Pm.HasChanged, E._EfcptFingerprintChanged);
        });
        t.Comment("Lifecycle hook: BeforeEfcptGeneration");
        CreateLifecycleHook(t, T.BeforeEfcptGeneration,
            condition: Condition_And(
                Condition_IsTrue(E.EfcptEnabled),
                Condition_IsFalse(E._EfcptIsSqlProject)));
        t.Target(T.EfcptGenerateModels, target =>
        {
            target.BeforeTargets(MsBuildTargets.CoreCompile);
            target.DependsOnTargets(T.BeforeEfcptGeneration);
            target.Inputs($"{Property(E._EfcptDacpacPath)};{Property(E._EfcptStagedConfig)};{Property(E._EfcptStagedRenaming)}");
            target.Outputs(Property(E.EfcptStampFile));
            target.Condition(Condition_And(
                Condition_And(
                    Condition_IsTrue(E.EfcptEnabled),
                    Condition_IsFalse(E._EfcptIsSqlProject)
                ),
                $"({Condition_IsTrue(E._EfcptFingerprintChanged)} or !Exists({Property(E.EfcptStampFile)}))"
            ));
            AddMakeDir(target, E.EfcptGeneratedDir);
            target.Task(Tk.RunEfcpt, task =>
            {
                task.MapParameters()
                    .WithToolConfiguration()
                    .WithResolvedConnection()
                    .WithStagedFiles()
                    .Build()
                    .Param(Pm.WorkingDirectory, Property(E.EfcptOutput))
                    .Param(Pm.DacpacPath, Property(E._EfcptDacpacPath))
                    .Param(Pm.OutputDir, Property(E.EfcptGeneratedDir))
                    .Param(Pm.TargetFramework, Property(P.TargetFramework))
                    .Param(Pm.ProjectPath, Property(P.MSBuildProjectFullPath))
                    .Param(Pm.LogVerbosity, Property(E.EfcptLogVerbosity));
            });
            target.Task(Tk.RenameGeneratedFiles, task =>
            {
                task.MapProps(
                    (Pm.GeneratedDir, E.EfcptGeneratedDir),
                    (Pm.LogVerbosity, E.EfcptLogVerbosity));
            });
            target.Task(Mt.WriteLinesToFile, task =>
            {
                task.MapProps((Pm.Lines, E._EfcptFingerprint))
                    .Map(Pm.File, E.EfcptStampFile)
                    .Param(Pm.Overwrite, V.True);
            });
        });
        t.Comment("Lifecycle hook: AfterEfcptGeneration");
        CreateLifecycleHook(t, T.AfterEfcptGeneration,
            condition: Condition_And(
                Condition_IsTrue(E.EfcptEnabled),
                Condition_IsFalse(E._EfcptIsSqlProject)));
        // ========================================================================
        // Split Outputs: Separate Models project from Data project
        // ========================================================================
        // When EfcptSplitOutputs=true, the Models project is the primary project
        // that runs efcpt and generates all files. Entity models stay in Models,
        // while DbContext and configurations are copied to the Data project.
        //
        // This approach works because Data depends on Models, so Models builds
        t.Comment("======================================================================== Split Outputs: Separate Models project from Data project ======================================================================== When EfcptSplitOutputs=true, the Models project is the primary project that runs efcpt and generates all files. Entity models stay in Models, while DbContext and configurations are copied to the Data project. This approach works because Data depends on Models, so Models builds first and generates the code before Data needs the types.");
        // Validate split outputs configuration and resolve Data project path.
        t.Comment("Validate split outputs configuration and resolve Data project path. Ensures the Data project exists and is properly configured.");
        t.Target(T.EfcptValidateSplitOutputs, target =>
        {
            target.DependsOnTargets(T.EfcptGenerateModels);
            target.Condition(Condition_And(
                Condition_And(
                    Condition_IsTrue(E.EfcptEnabled),
                    Condition_IsFalse(E._EfcptIsSqlProject)
                ),
                Condition_IsTrue(E.EfcptSplitOutputs)
            ));
            target.PropertyGroup(null, group =>
            {
                group.Property(E._EfcptDataProjectPath, Property(E.EfcptDataProject));
                group.Property(E._EfcptDataProjectPath, $"$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine({Property(P.MSBuildProjectDirectory)}, {Property(E.EfcptDataProject)}))))");
            });
            target.Error("EfcptSplitOutputs is enabled but EfcptDataProject is not set. Please specify the path to your Data project: <EfcptDataProject>..\\MyProject.Data\\MyProject.Data.csproj</EfcptDataProject>", $"{Property(E._EfcptDataProjectPath)} == ''");
            target.Error($"EfcptDataProject was specified but the file does not exist: {Property(E._EfcptDataProjectPath)}", $"!Exists({Property(E._EfcptDataProjectPath)})");
            target.PropertyGroup(null, group =>
            {
                group.Property(E._EfcptDataProjectDir, $"$([System.IO.Path]::GetDirectoryName({Property(E._EfcptDataProjectPath)}))\\");
                group.Property(E._EfcptDataDestDir, $"{Property(E._EfcptDataProjectDir)}{Property(E.EfcptDataProjectOutputSubdir)}");
            });
            target.Message($"Split outputs enabled. DbContext and configurations will be copied to: {Property(E._EfcptDataDestDir)}", V.High);
        });
        // Copy generated DbContext and configuration files to the Data
        // project. - DbContext files go to the root of the destination
        // - Configuration files go to a Configurations subfolder
        // - Files are deleted from the Models project after copying
        // Only runs when source files exist (i.e., when generation
        // actually occurred).
        t.Comment(
            "Copy generated DbContext and configuration files to the " +
            "Data project. - DbContext files go to the root of the " +
            "destination - Configuration files go to a Configurations " +
            "subfolder - Files are deleted from the Models project " +
            "after copying Only runs when source files exist (i.e., " +
            "when generation actually occurred).");
        t.Target(T.EfcptCopyDataToDataProject, target =>
        {
            target.DependsOnTargets(T.EfcptValidateSplitOutputs);
            target.Condition(
                Condition_And(
                    Condition_And(
                        Condition_IsTrue(E.EfcptEnabled),
                        Condition_IsFalse(E._EfcptIsSqlProject)
                    ),
                    Condition_IsTrue(E.EfcptSplitOutputs)
                ));
            target.ItemGroup(null, group =>
            {
                group.Include(
                    E._EfcptDbContextFiles,
                    $"{Property(E.EfcptGeneratedDir)}*.g.cs");
            });
            target.ItemGroup(null, group =>
            {
                group.Include(
                    E._EfcptConfigurationFiles,
                    $"{Property(E.EfcptGeneratedDir)}*Configuration.g.cs");
                group.Include(
                    E._EfcptConfigurationFiles,
                    $"{Property(E.EfcptGeneratedDir)}Configurations\\**\\*.g.cs");
            });
            target.PropertyGroup(null, group =>
            {
                group.Property(E._EfcptHasFilesToCopy, V.True);
            });
            var hasFilesCondition =
                $"{Condition_IsTrue(E._EfcptHasFilesToCopy)} and " +
                $"Exists({Property(E._EfcptDataDestDir)})";
            target.Task(
                Mt.RemoveDir,
                task => task.Param(Pm.Directories, Property(E._EfcptDataDestDir)),
                hasFilesCondition);
            AddMakeDir(target, E._EfcptDataDestDir);
            target.Task(
                Mt.MakeDir,
                task => task.Param(
                    Pm.Directories,
                    $"{Property(E._EfcptDataDestDir)}Configurations"),
                "'@(_EfcptConfigurationFiles)' != ''");
            target.Task(Mt.Copy, task =>
            {
                task.Param(Pm.SourceFiles, "@(_EfcptDbContextFiles)");
                task.Param(Pm.DestinationFolder, Property(E._EfcptDataDestDir));
                task.Param(Pm.SkipUnchangedFiles, V.True);
                task.OutputItem(Pm.CopiedFiles, E._EfcptCopiedDataFiles);
            }, "'@(_EfcptDbContextFiles)' != ''");
            target.Task(Mt.Copy, task =>
            {
                task.Param(Pm.SourceFiles, "@(_EfcptConfigurationFiles)");
                task.Param(
                    Pm.DestinationFolder,
                    $"{Property(E._EfcptDataDestDir)}Configurations");
                task.Param(Pm.SkipUnchangedFiles, V.True);
                task.OutputItem(Pm.CopiedFiles, E._EfcptCopiedDataFiles);
            }, "'@(_EfcptConfigurationFiles)' != ''");
            target.Message(
                $"Copied @(_EfcptCopiedDataFiles->Count()) data files " +
                $"to Data project: {Property(E._EfcptDataDestDir)}",
                V.High,
                "'@(_EfcptCopiedDataFiles)' != ''");
            target.Message(
                "Split outputs: No new files to copy " +
                "(generation was skipped)",
                V.Normal,
                Condition_IsFalse(E._EfcptHasFilesToCopy));
            AddDelete(
                target,
                E._EfcptDbContextFiles,
                "'@(_EfcptDbContextFiles)' != ''");
            AddDelete(
                target,
                E._EfcptConfigurationFiles,
                "'@(_EfcptConfigurationFiles)' != ''");
            target.Message(
                $"Removed DbContext and configuration files from " +
                $"Models project",
                V.Normal,
                Condition_IsTrue(E._EfcptHasFilesToCopy));
        });
        // Include generated files in compilation.
        // In split outputs mode (Models project), only include model
        // files (from Models folder). In normal mode, include all
        // generated files.
        t.Comment(
            "Include generated files in compilation. In split outputs " +
            "mode (Models project), only include model files (from " +
            "Models folder). In normal mode, include all generated " +
            "files.");
        t.AddEfcptTarget(T.EfcptAddToCompile)
            .ForEfCoreGeneration()
            .Before(MsBuildTargets.CoreCompile)
            .DependsOn(
                T.EfcptResolveInputs,
                T.EfcptUseDirectDacpac,
                T.EfcptEnsureDacpacBuilt,
                T.EfcptStageInputs,
                T.EfcptComputeFingerprint,
                T.EfcptGenerateModels,
                T.EfcptCopyDataToDataProject)
            .Build()
            .ItemGroup(null, group =>
            {
                group.Include(
                    MsBuildItems.Compile,
                    $"{Property(E.EfcptGeneratedDir)}Models\\**\\*.g.cs",
                    null,
                    Condition_IsTrue(E.EfcptSplitOutputs));
                group.Include(
                    MsBuildItems.Compile,
                    $"{Property(E.EfcptGeneratedDir)}**\\*.g.cs",
                    null,
                    Condition_IsFalse(E.EfcptSplitOutputs));
            });
        // Include external data files from another project (for Data
        // project consumption). Used when Data project has
        // EfcptEnabled=false but needs to compile copied
        // DbContext/configs.
        t.Comment(
            "Include external data files from another project (for " +
            "Data project consumption). Used when Data project has " +
            "EfcptEnabled=false but needs to compile copied " +
            "DbContext/configs.");
        t.Target(T.EfcptIncludeExternalData, target =>
        {
            target.BeforeTargets(MsBuildTargets.CoreCompile);
            target.Condition(
                Condition_And(
                    Condition_NotEmpty(E.EfcptExternalDataDir),
                    Condition_Exists(Property(E.EfcptExternalDataDir))));
            target.ItemGroup(
                null,
                group => group.Include(
                    MsBuildItems.Compile,
                    $"{Property(E.EfcptExternalDataDir)}**\\*.g.cs"));
            target.Message(
                $"Including external data files from: {Property(E.EfcptExternalDataDir)}",
                V.Normal);
        });
        t.Comment(
            "Clean target: remove efcpt output directory when " +
            "'dotnet clean' is run");
        t.AddEfcptTarget(T.EfcptClean)
            .WhenEnabled()
            .After(MsBuildTargets.Clean)
            .LogNormal(
                $"Cleaning efcpt output: {Property(E.EfcptOutput)}")
            .Build()
            .Task(Mt.RemoveDir, task =>
            {
                task.Param(Pm.Directories, Property(E.EfcptOutput));
            }, Condition_Exists(Property(E.EfcptOutput)));
        t.Comment(
            "Build Profiling: Finalize profiling at the end of the " +
            "build pipeline.");
        t.Target(T._EfcptFinalizeProfiling, target =>
        {
            target.AfterTargets(MsBuildTargets.Build);
            target.Condition(
                Condition_And(
                    Condition_IsTrue(E.EfcptEnabled),
                    Condition_IsTrue(E.EfcptEnableProfiling)));
            target.Task(Tk.FinalizeBuildProfiling, task =>
            {
                task.MapParameters()
                    .WithProjectContext()
                    .Build()
                    .Param(Pm.OutputPath, Property(E.EfcptProfilingOutput))
                    .Param(Pm.BuildSucceeded, V.True);
            });
        });

        return project;
    }
}
