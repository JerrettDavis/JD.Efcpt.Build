<Project>

  <!-- Determine the correct task assembly path based on MSBuild version -->
  <PropertyGroup>
    <!-- Use the appropriate .NET version for the task assembly -->
    <_EfcptTasksFolder Condition="'$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.12'))">net10.0</_EfcptTasksFolder>
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.10'))">net9.0</_EfcptTasksFolder>
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == ''">net8.0</_EfcptTasksFolder>

    <!-- Primary path: NuGet package location -->
    <_EfcptTaskAssembly>$(MSBuildThisFileDirectory)..\tasks\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>

    <!-- Fallback path: Local development (when building from source) -->
    <_EfcptTaskAssembly Condition="!Exists('$(_EfcptTaskAssembly)')">$(MSBuildThisFileDirectory)..\..\JD.Efcpt.Build.Tasks\bin\$(Configuration)\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>
    <_EfcptTaskAssembly Condition="!Exists('$(_EfcptTaskAssembly)') and '$(Configuration)' == ''">$(MSBuildThisFileDirectory)..\..\JD.Efcpt.Build.Tasks\bin\Debug\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>
  </PropertyGroup>

  <!-- Register MSBuild tasks - use AssemblyFile to avoid NuGet copying/locking the DLL -->
  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ResolveSqlProjAndInputs"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.EnsureDacpacBuilt"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.StageEfcptInputs"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ComputeFingerprint"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.RunEfcpt"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.RenameGeneratedFiles"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.QuerySchemaMetadata"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <!-- Main pipeline -->
  <Target Name="EfcptResolveInputs"
          Condition="'$(EfcptEnabled)' == 'true'">
    <ResolveSqlProjAndInputs
        ProjectFullPath="$(MSBuildProjectFullPath)"
        ProjectDirectory="$(MSBuildProjectDirectory)"
        Configuration="$(Configuration)"
        ProjectReferences="@(ProjectReference)"
        SqlProjOverride="$(EfcptSqlProj)"
        ConfigOverride="$(EfcptConfig)"
        RenamingOverride="$(EfcptRenaming)"
        TemplateDirOverride="$(EfcptTemplateDir)"
        SolutionDir="$(EfcptSolutionDir)"
        SolutionPath="$(EfcptSolutionPath)"
        ProbeSolutionDir="$(EfcptProbeSolutionDir)"
        OutputDir="$(EfcptOutput)"
        DefaultsRoot="$(MSBuildThisFileDirectory)Defaults"
        DumpResolvedInputs="$(EfcptDumpResolvedInputs)"
        EfcptConnectionString="$(EfcptConnectionString)"
        EfcptAppSettings="$(EfcptAppSettings)"
        EfcptAppConfig="$(EfcptAppConfig)"
        EfcptConnectionStringName="$(EfcptConnectionStringName)">
      <Output TaskParameter="SqlProjPath" PropertyName="_EfcptSqlProj" />
      <Output TaskParameter="ResolvedConfigPath" PropertyName="_EfcptResolvedConfig" />
      <Output TaskParameter="ResolvedRenamingPath" PropertyName="_EfcptResolvedRenaming" />
      <Output TaskParameter="ResolvedTemplateDir" PropertyName="_EfcptResolvedTemplateDir" />
      <Output TaskParameter="ResolvedConnectionString" PropertyName="_EfcptResolvedConnectionString" />
      <Output TaskParameter="UseConnectionString" PropertyName="_EfcptUseConnectionString" />
    </ResolveSqlProjAndInputs>
  </Target>

  <Target Name="EfcptQuerySchemaMetadata"
          AfterTargets="EfcptResolveInputs"
          BeforeTargets="EfcptStageInputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptUseConnectionString)' == 'true'">
    <QuerySchemaMetadata
        ConnectionString="$(_EfcptResolvedConnectionString)"
        OutputDir="$(EfcptOutput)"
        Provider="$(EfcptProvider)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="SchemaFingerprint" PropertyName="_EfcptSchemaFingerprint" />
    </QuerySchemaMetadata>
  </Target>

  <Target Name="EfcptUseDirectDacpac"
          DependsOnTargets="EfcptResolveInputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptUseConnectionString)' != 'true' and '$(EfcptDacpac)' != ''">
    <PropertyGroup>
      <_EfcptDacpacPath>$([System.IO.Path]::GetFullPath('$(EfcptDacpac)', '$(MSBuildProjectDirectory)'))</_EfcptDacpacPath>
      <_EfcptUseDirectDacpac>true</_EfcptUseDirectDacpac>
    </PropertyGroup>
    <Error Condition="!Exists('$(_EfcptDacpacPath)')"
           Text="EfcptDacpac was specified but the file does not exist: $(_EfcptDacpacPath)" />
    <Message Text="Using pre-built DACPAC: $(_EfcptDacpacPath)" Importance="high" />
  </Target>

  <Target Name="EfcptEnsureDacpac"
          DependsOnTargets="EfcptResolveInputs;EfcptUseDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptUseConnectionString)' != 'true' and '$(_EfcptUseDirectDacpac)' != 'true'">
    <EnsureDacpacBuilt
        SqlProjPath="$(_EfcptSqlProj)"
        Configuration="$(Configuration)"
        MsBuildExe="$(MSBuildBinPath)msbuild.exe"
        DotNetExe="$(EfcptDotNetExe)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="DacpacPath" PropertyName="_EfcptDacpacPath" />
    </EnsureDacpacBuilt>
  </Target>

  <Target Name="EfcptStageInputs"
          DependsOnTargets="EfcptEnsureDacpac;EfcptUseDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true'">
    <StageEfcptInputs
        OutputDir="$(EfcptOutput)"
        ProjectDirectory="$(MSBuildProjectDirectory)"
        ConfigPath="$(_EfcptResolvedConfig)"
        RenamingPath="$(_EfcptResolvedRenaming)"
        TemplateDir="$(_EfcptResolvedTemplateDir)"
        TemplateOutputDir="$(EfcptGeneratedDir)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="StagedConfigPath" PropertyName="_EfcptStagedConfig" />
      <Output TaskParameter="StagedRenamingPath" PropertyName="_EfcptStagedRenaming" />
      <Output TaskParameter="StagedTemplateDir" PropertyName="_EfcptStagedTemplateDir" />
    </StageEfcptInputs>
  </Target>

  <Target Name="EfcptComputeFingerprint"
          DependsOnTargets="EfcptStageInputs"
          Condition="'$(EfcptEnabled)' == 'true'">
    <ComputeFingerprint
        DacpacPath="$(_EfcptDacpacPath)"
        SchemaFingerprint="$(_EfcptSchemaFingerprint)"
        UseConnectionStringMode="$(_EfcptUseConnectionString)"
        ConfigPath="$(_EfcptStagedConfig)"
        RenamingPath="$(_EfcptStagedRenaming)"
        TemplateDir="$(_EfcptStagedTemplateDir)"
        FingerprintFile="$(EfcptFingerprintFile)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="Fingerprint" PropertyName="_EfcptFingerprint" />
      <Output TaskParameter="HasChanged" PropertyName="_EfcptFingerprintChanged" />
    </ComputeFingerprint>
  </Target>

  <Target Name="EfcptGenerateModels"
          DependsOnTargets="EfcptComputeFingerprint"
          BeforeTargets="CoreCompile"
          Inputs="$(_EfcptDacpacPath);$(_EfcptStagedConfig);$(_EfcptStagedRenaming)"
          Outputs="$(EfcptStampFile)"
          Condition="'$(EfcptEnabled)' == 'true' and ('$(_EfcptFingerprintChanged)' == 'true' or !Exists('$(EfcptStampFile)'))">
    <MakeDir Directories="$(EfcptGeneratedDir)" />
    <RunEfcpt
        ToolMode="$(EfcptToolMode)"
        ToolPackageId="$(EfcptToolPackageId)"
        ToolVersion="$(EfcptToolVersion)"
        ToolRestore="$(EfcptToolRestore)"
        ToolCommand="$(EfcptToolCommand)"
        ToolPath="$(EfcptToolPath)"
        DotNetExe="$(EfcptDotNetExe)"
        WorkingDirectory="$(EfcptOutput)"
        DacpacPath="$(_EfcptDacpacPath)"
        ConnectionString="$(_EfcptResolvedConnectionString)"
        UseConnectionStringMode="$(_EfcptUseConnectionString)"
        ConfigPath="$(_EfcptStagedConfig)"
        RenamingPath="$(_EfcptStagedRenaming)"
        TemplateDir="$(_EfcptStagedTemplateDir)"
        OutputDir="$(EfcptGeneratedDir)"
        LogVerbosity="$(EfcptLogVerbosity)" />
    <RenameGeneratedFiles
        GeneratedDir="$(EfcptGeneratedDir)"
        LogVerbosity="$(EfcptLogVerbosity)" />
    <WriteLinesToFile File="$(EfcptStampFile)" Lines="$(_EfcptFingerprint)" Overwrite="true" />
  </Target>

  <!--
    ========================================================================
    Split Outputs: Separate Models project from Data project
    ========================================================================
    When EfcptSplitOutputs=true, the Models project is the primary project
    that runs efcpt and generates all files. Entity models stay in Models,
    while DbContext and configurations are copied to the Data project.

    This approach works because Data depends on Models, so Models builds
    first and generates the code before Data needs the types.
  -->

  <!--
    Validate split outputs configuration and resolve Data project path.
    Ensures the Data project exists and is properly configured.
  -->
  <Target Name="EfcptValidateSplitOutputs"
          DependsOnTargets="EfcptGenerateModels"
          Condition="'$(EfcptEnabled)' == 'true' and '$(EfcptSplitOutputs)' == 'true'">

    <!-- Resolve Data project path -->
    <PropertyGroup>
      <_EfcptDataProjectPath Condition="'$(EfcptDataProject)' != ''">$([System.IO.Path]::GetFullPath('$(EfcptDataProject)', '$(MSBuildProjectDirectory)'))</_EfcptDataProjectPath>
    </PropertyGroup>

    <!-- Error if Data project not specified -->
    <Error Condition="'$(_EfcptDataProjectPath)' == ''"
           Text="EfcptSplitOutputs is enabled but EfcptDataProject is not set. Please specify the path to your Data project: &lt;EfcptDataProject&gt;..\MyProject.Data\MyProject.Data.csproj&lt;/EfcptDataProject&gt;" />

    <!-- Error if Data project doesn't exist -->
    <Error Condition="!Exists('$(_EfcptDataProjectPath)')"
           Text="EfcptDataProject was specified but the file does not exist: $(_EfcptDataProjectPath)" />

    <!-- Resolve Data project directory -->
    <PropertyGroup>
      <_EfcptDataProjectDir>$([System.IO.Path]::GetDirectoryName('$(_EfcptDataProjectPath)'))\</_EfcptDataProjectDir>
      <_EfcptDataDestDir>$(_EfcptDataProjectDir)$(EfcptDataProjectOutputSubdir)</_EfcptDataDestDir>
    </PropertyGroup>

    <Message Text="Split outputs enabled. DbContext and configurations will be copied to: $(_EfcptDataDestDir)" Importance="high" />
  </Target>

  <!--
    Copy generated DbContext and configuration files to the Data project.
    Copies root-level .g.cs files (DbContext, configurations) but NOT the Models folder.
    Cleans destination first to remove stale files, then copies fresh.
  -->
  <Target Name="EfcptCopyDataToDataProject"
          DependsOnTargets="EfcptValidateSplitOutputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(EfcptSplitOutputs)' == 'true'">

    <!-- Find data files to copy (root-level .g.cs files, excluding Models folder) -->
    <ItemGroup>
      <_EfcptDataFilesToCopy Include="$(EfcptGeneratedDir)*.g.cs" />
      <_EfcptDataFilesToCopy Include="$(EfcptGeneratedDir)Configurations\**\*.g.cs" />
    </ItemGroup>

    <!-- Clean destination directory first to remove stale files -->
    <RemoveDir Directories="$(_EfcptDataDestDir)" Condition="Exists('$(_EfcptDataDestDir)')" />
    <MakeDir Directories="$(_EfcptDataDestDir)" />

    <!-- Copy data files preserving directory structure -->
    <Copy SourceFiles="@(_EfcptDataFilesToCopy)"
          DestinationFiles="@(_EfcptDataFilesToCopy->'$(_EfcptDataDestDir)%(RecursiveDir)%(Filename)%(Extension)')"
          SkipUnchangedFiles="true"
          Condition="'@(_EfcptDataFilesToCopy)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="_EfcptCopiedDataFiles" />
    </Copy>

    <Message Text="Copied @(_EfcptCopiedDataFiles->Count()) data files to Data project: $(_EfcptDataDestDir)"
             Condition="'@(_EfcptCopiedDataFiles)' != ''"
             Importance="high" />

    <Message Text="No data files found to copy to Data project. Ensure your templates generate DbContext and configuration files in $(EfcptGeneratedDir)"
             Condition="'@(_EfcptDataFilesToCopy)' == ''"
             Importance="high" />
  </Target>

  <!--
    Include generated files in compilation.
    In split outputs mode (Models project), only include model files (from Models folder).
    In normal mode, include all generated files.
  -->
  <Target Name="EfcptAddToCompile"
          BeforeTargets="CoreCompile"
          DependsOnTargets="EfcptResolveInputs;EfcptUseDirectDacpac;EfcptEnsureDacpac;EfcptStageInputs;EfcptComputeFingerprint;EfcptGenerateModels;EfcptCopyDataToDataProject"
          Condition="'$(EfcptEnabled)' == 'true'">
    <ItemGroup>
      <!-- In split outputs mode (Models project is primary), only include model files -->
      <Compile Include="$(EfcptGeneratedDir)Models\**\*.g.cs"
               Visible="false"
               Condition="'$(EfcptSplitOutputs)' == 'true'" />

      <!-- In normal mode, include all generated files -->
      <Compile Include="$(EfcptGeneratedDir)**\*.g.cs"
               Visible="false"
               Condition="'$(EfcptSplitOutputs)' != 'true'" />
    </ItemGroup>
  </Target>

  <!--
    Include external data files from another project (for Data project consumption).
    Used when Data project has EfcptEnabled=false but needs to compile copied DbContext/configs.
  -->
  <Target Name="EfcptIncludeExternalData"
          BeforeTargets="CoreCompile"
          Condition="'$(EfcptExternalDataDir)' != '' and Exists('$(EfcptExternalDataDir)')">
    <ItemGroup>
      <Compile Include="$(EfcptExternalDataDir)**\*.g.cs" Visible="false" />
    </ItemGroup>
    <Message Text="Including external data files from: $(EfcptExternalDataDir)" Importance="normal" />
  </Target>

  <!-- Clean target: remove efcpt output directory when 'dotnet clean' is run -->
  <Target Name="EfcptClean"
          AfterTargets="Clean"
          Condition="'$(EfcptEnabled)' == 'true'">
    <Message Text="Cleaning efcpt output: $(EfcptOutput)" Importance="normal" />
    <RemoveDir Directories="$(EfcptOutput)" Condition="Exists('$(EfcptOutput)')" />
  </Target>

</Project>
